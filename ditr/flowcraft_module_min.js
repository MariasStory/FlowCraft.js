!function(t){const e={IDLE:"idle",RUNNING:"running",PAUSED:"paused",COMPLETED:"completed",ABORTED:"aborted",ERROR:"error"},o={NONE:0,ERROR:1,INFO:2,DEBUG:3},n={PAUSE:"FLOWCRAFT_PAUSE"},s={ABORT:"FLOWCRAFT_ABORT",SKIP:"FLOWCRAFT_SKIP",RETRY:"FLOWCRAFT_RETRY"};function i(){return new Promise((t=>setTimeout(t,0)))}function r(){const t=(t,...e)=>console[t](...e);return{error:(...e)=>t("error",...e),warn:(...e)=>t("warn",...e),info:(...e)=>t("info",...e),debug:(...e)=>t("debug",...e)}}class a{constructor(t,e,o){this._flowCraft=t,this._flowName=e,this._executionContext=o,this._promise=new Promise(((t,e)=>{this._resolvePromise=t,this._rejectPromise=e}))}get result(){return this._promise}getState(){return{flowName:this._flowName,status:this._executionContext.status,currentTaskIndex:this._executionContext.currentTaskIndex,context:{...this._executionContext.context},lastError:this._executionContext.lastError,signalData:this._executionContext.signalData}}pause(){this._executionContext.status===e.RUNNING?(this._executionContext.pauseRequested=!0,this._flowCraft._log(this._executionContext.logLevel,this._executionContext.logger.info,`[FlowCraft] Pause requested for flow '${this._flowName}'`)):this._flowCraft._log(this._executionContext.logLevel,this._executionContext.logger.warn,`[FlowCraft] Cannot pause flow '${this._flowName}': not running (status: ${this._executionContext.status})`)}resume(t=null){this._executionContext.status===e.PAUSED?(this._flowCraft._log(this._executionContext.logLevel,this._executionContext.logger.info,`[FlowCraft] Resuming flow '${this._flowName}'...`),null!==t&&"object"==typeof t&&(Object.assign(this._executionContext.context,t),this._flowCraft._log(this._executionContext.logLevel,this._executionContext.logger.debug,`[FlowCraft] Merged resume data into context for '${this._flowName}'.`)),this._executionContext.status=e.RUNNING,this._executionContext.signalData=null,setTimeout((()=>this._flowCraft._executeFlow(this._executionContext)),0)):this._flowCraft._log(this._executionContext.logLevel,this._executionContext.logger.warn,`[FlowCraft] Cannot resume flow '${this._flowName}': not paused (status: ${this._executionContext.status})`)}abort(t="Manual abort"){this._executionContext.status===e.RUNNING||this._executionContext.status===e.PAUSED?(this._executionContext.status=e.ABORTED,this._executionContext.lastError=new Error(`Flow aborted: ${t}`),this._flowCraft._log(this._executionContext.logLevel,this._executionContext.logger.warn,`[FlowCraft] Aborting flow '${this._flowName}'. Reason: ${t}`),this._rejectPromise(this._executionContext.lastError)):this._flowCraft._log(this._executionContext.logLevel,this._executionContext.logger.warn,`[FlowCraft] Cannot abort flow '${this._flowName}': not running or paused (status: ${this._executionContext.status})`)}}const l=new class{constructor(){this.version="1.0.0",this._flows={},this._activeInstances=new Map,this._executionCounter=0}_log(t,e,...n){(t>=o.ERROR&&(e===console.error||e.name&&e.name.includes("error"))||t>=o.INFO&&(e===console.info||e===console.warn||e.name&&(e.name.includes("info")||e.name.includes("warn")))||t>=o.DEBUG&&(e===console.debug||e.name&&e.name.includes("debug")))&&e(...n)}define(t,e,n={}){if(this._flows[t]&&console.warn(`[FlowCraft] Warning: Redefining flow '${t}'.`),!Array.isArray(e)||0===e.length)throw new Error(`[FlowCraft] Flow '${t}' must have at least one task defined.`);const s={tasks:e.map(((e,o)=>{if("function"==typeof e)return{id:`task_${o}`,func:e,options:{},retries:0};if("object"==typeof e&&"function"==typeof e.func)return{id:e.id||`task_${o}`,func:e.func,onError:e.onError,options:e.options||{},retries:0};throw new Error(`[FlowCraft] Invalid task definition at index ${o} for flow '${t}'. Must be a function or an object with a 'func' property.`)})),options:{logLevel:void 0!==n.logLevel?n.logLevel:o.INFO,logger:n.logger||r(),onError:n.onError,yieldBeforeTask:n.yieldBeforeTask||!1,yieldAfterTask:n.yieldAfterTask||!1,defaultMaxRetries:n.defaultMaxRetries||0,...n}};this._flows[t]=s,this._log(s.options.logLevel,s.options.logger.info,`[FlowCraft] Defined flow '${t}' with ${s.tasks.length} tasks.`)}run(t,o={}){const n=this._flows[t];if(!n)throw new Error(`[FlowCraft] Flow '${t}' is not defined.`);this._executionCounter++;const s=`${t}_${this._executionCounter}`,i={id:s,flowName:t,tasks:n.tasks.map((t=>({...t,retries:0}))),options:n.options,logLevel:n.options.logLevel,logger:n.options.logger,context:{...o},currentTaskIndex:0,status:e.IDLE,lastError:null,signalData:null,pauseRequested:!1,flowInstance:null},r=new a(this,t,i);return i.flowInstance=r,this._activeInstances.set(s,i),this._log(i.logLevel,i.logger.info,`[FlowCraft] Starting flow '${t}' (Execution ID: ${s})`),i.status=e.RUNNING,setTimeout((()=>this._executeFlow(i)),0),r}async _executeFlow(t){const{flowName:o,tasks:r,options:a,logger:l,logLevel:u}=t;for(;t.currentTaskIndex<r.length;){if(t.status!==e.RUNNING)return this._log(u,l.warn,`[FlowCraft] Flow '${o}' execution loop interrupted (Status: ${t.status}).`),void(t.status===e.ABORTED&&t.flowInstance||t.status===e.PAUSED&&t.flowInstance);const f=t.currentTaskIndex,c=r[f],w={id:c.id,index:f,retries:c.retries,maxRetries:c.options?.maxRetries??a.defaultMaxRetries};if((c.options?.yieldBefore||a.yieldBeforeTask)&&(this._log(u,l.debug,`[FlowCraft][${o}] Yielding before task '${w.id}'`),await i(),t.status!==e.RUNNING))continue;let g=null,d=null;const _=(t,e=null)=>{g=t,d=e,this._log(u,l.info,`[FlowCraft][${o}] Task '${w.id}' signaled: ${t}`)};this._log(u,l.info,`[FlowCraft][${o}] Running task ${f+1}/${r.length}: '${w.id}'`),this._log(u,l.debug,`[FlowCraft][${o}] Task context before execution:`,{...t.context});try{const s=await c.func(t.context,{signal:_,taskInfo:w});if(g===n.PAUSE)return t.status=e.PAUSED,t.signalData=d,void this._log(u,l.info,`[FlowCraft][${o}] Paused by task '${w.id}'.`);this._log(u,l.debug,`[FlowCraft][${o}] Task '${w.id}' completed. Result:`,s),c.retries=0}catch(n){this._log(u,l.error,`[FlowCraft][${o}] Error in task '${w.id}':`,n),t.lastError=n;let i=s.ABORT;if("function"==typeof c.onError)try{this._log(u,l.debug,`[FlowCraft][${o}] Calling task-specific onError for '${w.id}'`),i=await c.onError(n,t.context,w)}catch(t){this._log(u,l.error,`[FlowCraft][${o}] Error in task-specific onError handler for '${w.id}':`,t),i=s.ABORT}else if("function"==typeof a.onError)try{this._log(u,l.debug,`[FlowCraft][${o}] Calling flow-level onError for task '${w.id}'`),i=await a.onError(n,t.context,w)}catch(t){this._log(u,l.error,`[FlowCraft][${o}] Error in flow-level onError handler:`,t),i=s.ABORT}if(i===s.RETRY){if(c.retries++,c.retries<=w.maxRetries){this._log(u,l.warn,`[FlowCraft][${o}] Retrying task '${w.id}' (Attempt ${c.retries}/${w.maxRetries})...`);continue}this._log(u,l.error,`[FlowCraft][${o}] Max retries (${w.maxRetries}) exceeded for task '${w.id}'. Aborting.`),i=s.ABORT}if(i===s.SKIP){this._log(u,l.warn,`[FlowCraft][${o}] Skipping failed task '${w.id}'.`),t.currentTaskIndex++,c.retries=0;continue}if(i===s.ABORT)return this._log(u,l.error,`[FlowCraft][${o}] Aborting flow due to error in task '${w.id}'.`),t.status=e.ERROR,t.flowInstance&&t.flowInstance._rejectPromise(n),void this._activeInstances.delete(t.id);this._log(u,l.info,`[FlowCraft][${o}] Error handled for task '${w.id}'. Using fallback value:`,i),c.retries=0}if(!c.options?.yieldAfter&&!a.yieldAfterTask||(this._log(u,l.debug,`[FlowCraft][${o}] Yielding after task '${w.id}'`),await i(),t.status===e.RUNNING)){if(t.pauseRequested)return t.status=e.PAUSED,t.pauseRequested=!1,void this._log(u,l.info,`[FlowCraft][${o}] Paused externally after task '${w.id}'.`);t.currentTaskIndex++}}t.status===e.RUNNING&&(t.status=e.COMPLETED,this._log(u,l.info,`[FlowCraft][${o}] Flow completed successfully.`),t.flowInstance&&t.flowInstance._resolvePromise(t.context),this._activeInstances.delete(t.id))}};l.STATUS=e,l.LOG_LEVEL=o,l.SIGNAL_TYPE=n,l.ERROR_ACTION=s,"function"==typeof define&&define.amd?define([],(function(){return l})):"object"==typeof module&&module.exports?module.exports=l:t.FlowCraft=l}("undefined"!=typeof window?window:global);